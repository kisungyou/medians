% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geometric_sphere.R
\name{gmed_sphere}
\alias{gmed_sphere}
\title{Geometric Median on Unit Hypersphere}
\usage{
gmed_sphere(X, weights = NULL, ...)
}
\arguments{
\item{X}{an \eqn{(n\times p)} matrix whose rows are unit-norm vectors in \eqn{\mathbb{R}^p}.}

\item{weights}{\code{NULL} for equal weight \code{rep(1/n,n)}; otherwise, it has to be a vector of length \eqn{n}.}

\item{...}{extra parameters:\describe{
\item{maxiter}{maximum number of iterations (default: 100).}
\item{abstol}{Cauchy stopping criterion (default: 1e-8).}
}}
}
\value{
a named list containing\describe{
\item{solution}{an optimal solution as a length-\eqn{p} unit-norm vector.}
\item{time}{elapsed wall-clock time for computation measured in seconds.}
}
}
\description{
Unit hypersphere \eqn{\mathbb{S}^{p-1}} is a collection of unit-norm vectors in 
\eqn{\mathbb{R}^p}, whose dimension is \eqn{p-1}. For a collection of \eqn{p}-dimensional 
unit norm vectors, it computes a weighted version of the geometric median 
under geodesic or chordal distance.
}
\examples{
\donttest{
## set seed for reproducibility
set.seed(496)

## generate sin(x) data with noise for 100 replicates
## this time, each signal is normalized to have norm 1
X = seq(from=0,to=10,length.out=20)
Y = array(0,c(100,20))
for (i in 1:100){
   Y[i,] = sin(X) + stats::rnorm(20, sd=0.25)
   Y[i,] = Y[i,]/sqrt(sum(Y[i,]^2))
}

## compute mean as a baseline for comparison
vecL2 = base::colMeans(Y)

## compute medians under two geometries
vecLI = gmed_sphere(Y, geometry="intrinsic")$solution 
vecLE = gmed_sphere(Y, geometry="extrinsic")$solution

## compute deviation from the normalized signal
signal = sin(X)
signal = signal/sqrt(sum(signal^2))

devL2  = sqrt(sum(vecL2-signal)^2)
devLE  = sqrt(sum(vecLE-signal)^2)
devLI  = sqrt(sum(vecLI-signal)^2)

## visualize
yvis <- c(-0.5, 0.5) # custom range for y-axis plotting
opar <- par(no.readonly=TRUE)
par(mfrow=c(2,2), pty="s")
matplot(t(Y[1:5,]), type="l", main="5 generated data", ylim=yvis)
plot(X, vecL2, type="l", col="green", main=paste0("mean:error=",round(devL2,4)), ylim=yvis)
lines(X, signal, lwd=1, lty=3)
plot(X, vecLE, type="l", col="red",  main=paste0("extrinsic median:error=",round(devLE,4)), ylim=yvis)
lines(X, signal, lwd=1, lty=3)
plot(X, vecLI, type="l", col="blue",  main=paste0("intrinsic median:error=",round(devLI,4)), ylim=yvis)
lines(X, signal, lwd=1, lty=3)
par(opar)
}

}
\concept{geometric}
